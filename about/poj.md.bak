语言 Pascal/C/C++/Java/Fortran

## 0x00 最长上升子序列

> 时间限制: 2000MS 	  	内存限制: 65536K

**Description**

设有由n个不相同的整数组成的数列，记为:a(1)、a(2)、……、a(n)且a(i)<>a(j) (i<>j)。
例如3，18，7，14，10，12，23，41，16，24。若存在i1<i2<i3< … < ie 且有a(i1)<a(i2)< … <a(ie)则称为长度为e的上升序列。
如上例中3，18，23，24就是一个长度为4的上升序列，同时也有3，7，10，12，16，24长度为6的上升序列。

给出一序列，求出该序列的最长上升子序列的长度。

**Input**

第一行为表示序列长度的一个数字N (1 <= N <= 1000)。第二行为用空格分割的N个数字组成的数字序列，每个数字的大小在0～10000之间。

**Output**

输出为一个整数，表示输入序列的最长上升子序列的长度

**Sample Input**

```
7
1 7 3 5 9 4 8
```

**Sample Output**

```
4
```

--------

## 0x01 三土的梦

> 时间限制: 200/100MS (Java/Others)     内存限制: 1300/1300KB (Java/Others)

**Description**

一天，三土去迅雷面试，面试官给了他这么一个问题。

> 给你2万个String，长度都是100，然后把这些字符串丢入一个 set< string >g 中，问set里含有多少个元素？
> g 是一个用来存储字符串、具有去重功能的容器，即相同（当且仅当长度一样且对应位置的字符都一样）字符串在 g 中只能保留一个。

三土前晚没睡好，随手写了一个程序交给面试官，然后就gg了。

```
#include<iostream>
#include<string>
#include<set>
using namespace std;
string s;
set<string>g;
int main(){
    for(int k=1;k<=20000;k++){
        cin>>s;
        g.insert(s);
    }
    cout<<g.size()<<endl;
    return 0;
}
```

三土醒来之后，发现这只是一个梦（还好只是个梦>_<）。他回忆起梦中的面试官给他的内存限制和时间限制非常低，这么做肯定过不了，那么，现在你不在梦中，你能解决这个问题么？

**Input**

单case
每个case有且只有2万行，每一行包含一个字符串，每行字符串的长度都为100 （样例除外）
字符集：大写英文字母（A－Z），小写英文字母（a－z），数字（0－9）

**Output**

输出一个整数，表示最终set里含有多少个元素。

**Sample Input**

```
aaAa
aaAa
bbbb
1234
bbbb
bbbb
ee09
```

**Sample Output**

```
4
```

--------

## 0x02 滑雪

> 时间限制: 2000MS 	  	内存限制: 65536K

**Description**

Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子 

 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9

一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。

**Input**

输入的第一行表示区域的行数R和列数C(1 <= R,C <= 100)。下面是R行，每行有C个整数，代表高度h，0<=h<=10000。

**Output**

输出最长区域的长度。

**Sample Input**

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

**Sample Output**

```
25
```

